#!/usr/bin/env ruby

require File.join(File.dirname(__FILE__), 'document-cache' )
require File.join(File.dirname(__FILE__), 'vocabulary-chest' )
require 'rubygems'
require 'amatch'
require 'colorize'

class Game
	def initialize
		@failures = 0
		@turn = 0
	end

	def pick_choices_for word, words
		others = words.reject{|w| w == word}
		choices = (others.shuffle[0,4] + [word])
		choices.shuffle
	end

	def hit_rate
		rate = 100 - @failures / @turn.to_f * 100
		rate >= 0 ? rate : 0
	end

	def deumlaut w
		w.gsub("ä", "ae").gsub("ö", "oe").gsub("ü", "ue")
	end

	def proximity one, other
		Amatch::Levenshtein.new(deumlaut(one).downcase).match(deumlaut(other).downcase)
	end

	def get_an_answer_for correct_answer
		STDOUT.write("> ")
		answer = STDIN.gets.chomp

		while answer != '?' and (distance = proximity(answer, correct_answer)) > 1
			@failures += 1
			puts "Nope. Try again.".red
			puts
			STDOUT.write("> ")
			answer = STDIN.gets.chomp
		end

		[answer, distance]
	end

	def extract_matching_word word, sentence
		stem = VocabularyChest::stem(word)
		VocabularyChest::sanitize(sentence.split(" ").find{|w| VocabularyChest::stem(w) == stem })
	end

	def fetch_definition word
		definitions = `dict #{word} 2>/dev/null | grep '     ' | head -2`.chomp.gsub("     ","").split(/[\r\n]/)
		definitions.uniq.join(" -- ")
	end

	def show_question_for word, sentence, words
		puts
		puts
		puts
		puts "Turn #{@turn}".blue
		puts "#{words.size} words".blue
		color = hit_rate < 75 ? :red : 'green'
		puts "Hit rate: #{'%i' % hit_rate}%".send(color)
		puts "------------------------------------------------------------".blue
		puts
		puts sentence.gsub(extract_matching_word(word, sentence), "______").strip
		puts 
		puts "Choices: [".blue + " #{pick_choices_for(word, words).join(" - ")} " + "]".blue
		puts
	end

	def play words, &block
		words.shuffle.each{|word|
			@turn += 1

			matches = DocumentCache.find_examples_for(word, 10)
			if matches.empty?
				puts "Sorry. We do not find an example for: #{word}."
				next
			end

			sentence = matches.sort{|a, b| a.size <=> b.size}.first
			show_question_for(word, sentence, words)
			correct_answer = extract_matching_word(word, sentence)

			answer, distance = get_an_answer_for(correct_answer)
			puts
			if answer == '?'
				@failures += 1
				puts "The answer was: #{correct_answer.red}."
				sleep 1
			elsif distance > 0
				puts "Almost... The answer was: #{correct_answer.yellow}."
				sleep 1
			else
				puts "Correct! The answer was: #{correct_answer.green}."
			end

			definition = fetch_definition(correct_answer)
			puts "\n#{correct_answer.blue} means: #{definition}" if !definition.empty?

			yield(@turn, hit_rate)
		}

		play(words, &block)
	end
end

if __FILE__ == $0
	def get_input
		if !ARGV.empty?
			File.open(ARGV[0]){|f| f.read}
		else
			STDIN.read
		end
	end

	input = get_input
	words = input.split("\n")
	words.reject!{|w| DocumentCache.find_examples_for(w).empty?}

	Game.new.play(words){|turn, hit_rate|
		if turn > words.size and (hit_rate > 95)
			puts "Congratulations. Here is a star for you: *"
			exit(0)
		end
	}
end
